{"version":3,"sources":["apigee/errors/joiErrorParser.js"],"names":["parsePath","path","Array","length","reduce","current","value","concat","result","arrayIndexes","match","forEach","index","indexPosition","substring","indexParsed","split","join","buildJoiError","error","errorDetails","data","details","parameterPath","context","label","parameterType","output","payload","validation","source","errorType","type","missing","joiError","parameters","code","buildGenericErrors","statusCode","message"],"mappings":"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","file":"joiErrorParser.js","sourcesContent":["import errorParser from './errorParser'\nimport __joiToErrorCatalog from './joiErrorCatalog'\n\nlet parsePath = path => {\n  if (path instanceof Array) {\n    path = path.length === 0 ? [''] : path\n    path = path.reduce((current, value) => {\n      return current.concat('.').concat(value)\n    })\n  }\n\n  let result = path\n  let arrayIndexes = path.match(/(^\\d{1,}[.])|([.]\\d{1,}[.])|([.]\\d{1,}$)/g)\n  if (arrayIndexes && arrayIndexes.length > 0) {\n    arrayIndexes.forEach(index => {\n      let indexPosition = index.substring(0, 1) === '.' ? (index.substring(index.length - 1, index.length) === '.' ? 'inner' : 'end') : 'begin'\n      let indexParsed = ''\n      if (indexPosition === 'begin') {\n        indexParsed = '[' + index.substring(0, index.length - 1) + '].'\n      } else if (indexPosition === 'inner') {\n        indexParsed = '[' + index.substring(1, index.length - 1) + '].'\n      } else if (indexPosition === 'end') {\n        indexParsed = '[' + index.substring(1, index.length) + ']'\n      }\n      result = result.split(index).join(indexParsed)\n    })\n  }\n  return result\n}\n\nlet buildJoiError = error => {\n  let errorDetails = error.data.details\n  let parameterPath = parsePath(errorDetails[0].path)\n\n  parameterPath = parameterPath === '' ? errorDetails[0].context.label : parameterPath\n\n  let parameterType = error.output.payload.validation.source\n  if (parameterType === 'params') {\n    parameterType = 'path'\n  }\n\n  if (parameterType === 'payload') {\n    parameterType = 'body'\n  }\n\n  let errorType = errorDetails[0].type\n\n  /**\n   * Tratamento para o error type date.isoDate, seguindo a convenção ISO-8601\n   */\n  if (errorType === 'object.and') {\n    parameterPath = errorDetails[0].context.missing\n  }\n\n  let joiError = __joiToErrorCatalog[errorType]\n  if (!joiError) {\n    return errorParser(10000, `- Error code not found for joi error ${errorType}`)\n  }\n\n  let parameters = joiError.parameters(errorDetails[0], [parameterType, parameterPath])\n\n  return errorParser(joiError.code, parameters)\n}\n\nlet buildGenericErrors = error => {\n  if (error.output.statusCode === 401) {\n    return errorParser(30001, 'make sure the header parameter Authorization is valid')\n  }\n\n  return errorParser(10000, `- Error code not found for joi error ${error.output.payload.message}`)\n}\n\nexport default {buildJoiError, buildGenericErrors}\n"]}